[{"content":" Java 8u191 +，10及更高版本上可用\n1 2 3 4 -XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0 -XX:MinRAMPercentage=75.0 -XX:InitialRAMPercentage=75.0 参考资料 What does UseContainerSupport VM parameter do? Docker support in Java 8 — finally! Best practices: Java memory arguments for Containers 容器环境的JVM内存设置最佳实践 ","permalink":"https://nextyu.github.io/posts/jvm/%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83jvm%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","summary":"容器环境JVM内存参数最佳实践","title":"容器环境JVM内存参数最佳实践"},{"content":"K3s安装Kubernetes Dashboard，方便在线管理服务。\n在上一篇文章ubuntu20.04安装K3s集群，我们已经搭建好了K3s集群。\nk8s-master主机\n在k8s-master主机安装Kubernetes Dashboard。\n先部署Kubernetes Dashboard\n1 2 3 GITHUB_URL=https://github.com/kubernetes/dashboard/releases VERSION_KUBE_DASHBOARD=$(curl -w \u0026#39;%{url_effective}\u0026#39; -I -L -s -S ${GITHUB_URL}/latest -o /dev/null | sed -e \u0026#39;s|.*/||\u0026#39;) sudo k3s kubectl create -f https://raw.githubusercontent.com/kubernetes/dashboard/${VERSION_KUBE_DASHBOARD}/aio/deploy/recommended.yaml 接着配置控制权限\n新建俩文件\ndashboard.admin-user.yml\n1 2 3 4 5 apiVersion: v1 kind: ServiceAccount metadata: name: admin-user namespace: kubernetes-dashboard dashboard.admin-user-role.yml\n1 2 3 4 5 6 7 8 9 10 11 12 apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: admin-user roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: ServiceAccount name: admin-user namespace: kubernetes-dashboard 部署配置\n1 sudo k3s kubectl create -f dashboard.admin-user.yml -f dashboard.admin-user-role.yml 获取Bearer Token\n这个Token，用于在网页端登陆Dashboard\n1 sudo k3s kubectl -n kubernetes-dashboard create token admin-user 1 eyJhbGciOiJSUzI1NiIsImtpZCI6IkNmaWoyX1Q3SUxxUDczaXJfbExqRG90VHYxQ0JyR3VGRXYtRUpxejJ6cncifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiLCJrM3MiXSwiZXhwIjoxNjcxMDk0NDQ4LCJpYXQiOjE2NzEwOTA4NDgsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhZG1pbi11c2VyIiwidWlkIjoiMDY4NjY3OGYtYTVjZS00MWNmLWIyOTEtMjUwNDE1N2IyZjQxIn19LCJuYmYiOjE2NzEwOTA4NDgsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlcm5ldGVzLWRhc2hib2FyZDphZG1pbi11c2VyIn0.v4vfHpsF95izX2eGgUpfc_NSpa17Xbh5gldPyiIYw6g-QyPcpufKjPIvGahHSVc-Qwvr418PLypQ1xtSPKS6S9uCQlBNf-1LA_pbxb4iJZQm59cJeI9avnbSp1T3lM2EbrRABaiicL54AHqFQ5ZTu4nkd_aRpSYraIQrpZbptFgIGm4WtfTsGcNNhxulnOGuOJfua-ZpixFaEE2wMWGDjyisPBu1L2jM6QGWVPkfYXe1hZ0ygG5NISQLKK1G4GjD0J1YqQkp8DcHkdgJQNQqN35l8rihopx6y6Vg71xKUliswFiPIZMzvcpMeoj8LRSShAWxDHXDnmL27w4GFvppkw 通过Kube Proxy登陆Dashboard\n1 2 3 4 5 6 # 启动Kube Proxy，会暴露8001端口 sudo k3s kubectl proxy # 终端会一直挂起 Starting to serve on 127.0.0.1:8001 注意！！！现在我们需要在win10浏览器里面打开Dashboard，直接输入k8s-master的ip是打不开的，需要在win10上面创建一个通向k8s-master的SSH隧道。\n打开win10上的ssh客户端软件（随便一个都行），比如：WindTerm\n需要替换为自己的k8s-master的用户和ip\n1 2 3 ssh -N -L localhost:8001:localhost:8001 master@192.168.66.42 # 接着输入对应的用户密码，终端会一直挂起 接着在win10浏览器里面打开\n1 http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/ 使用上面得到的Token就可以登录了。\n注意！！！Token有有效期，过一段时间失效了，重新使用命令生成再使用就行。\n参考资料 Kubernetes Dashboard Installation steps for K3s dashboard ","permalink":"https://nextyu.github.io/posts/k8s/k3s%E5%AE%89%E8%A3%85kubernetes-dashboard/","summary":"K3s安装Kubernetes Dashboard，方便在线管理服务。 在上一篇文章ubuntu20.04安装K3s集群，我们已经搭建好了K3s","title":"K3s安装Kubernetes Dashboard"},{"content":"学习K8s为什么要安装K3s？K3s是轻量级的K8s，完全兼容K8s，和K8s操作也是一样的，安装简单，资源占用少，完全满足学习使用要求，学习阶段没有必要把大量的时间浪费在安装K8s上，生产环境一般都会直接买云服务器厂商的K8s，不用自己搭建。\n运行环境 win10使用VMware Workstation安装ubuntu-20.04。\nK3s版本\nv1.25.4+k3s1\n规划\nk8s-master 192.168.66.42 k8s-worker1 192.168.66.43 k8s-worker2 192.168.66.45 内存：2G、CPU：2核、硬盘：20G\n任意内网ip就行，保证三台服务器能互相ping通。\n准备工作 需要在三台机器上都执行如下操作：\n关闭防火墙 1 sudo ufw disable 关闭swap 1 sudo vim /etc/fstab 找到 /swap.img none swap sw 0 0，在行首添加 # 变成#/swap.img none swap sw 0 0\n重启系统并验证\n1 sudo swapon --show 输出为空即表示生效\nhostname 需要确保三台机器的hostname是不同的\n可以使用hostnamectl查看hostname\n1 hostnamectl 1 2 3 4 5 6 7 8 9 Static hostname: k8s-master Icon name: computer-vm Chassis: vm Machine ID: 2dfc205478df4165ad6cddc376b83a94 Boot ID: 3edc65716421404cb48164c35980a5b7 Virtualization: vmware Operating System: Ubuntu 20.04.5 LTS Kernel: Linux 5.4.0-135-generic Architecture: x86-64 1 2 3 4 5 6 7 8 9 Static hostname: k8s-worker1 Icon name: computer-vm Chassis: vm Machine ID: 2dfc205478df4165ad6cddc376b83a94 Boot ID: 0fd037607afb49f285ad525e765e8943 Virtualization: vmware Operating System: Ubuntu 20.04.5 LTS Kernel: Linux 5.4.0-135-generic Architecture: x86-64 设置hostname\n1 2 3 sudo hostnamectl set-hostname k8s-master sudo hostnamectl set-hostname k8s-worker1 sudo hostnamectl set-hostname k8s-worker1 ``\n下载K3s安装包 安装脚本install.sh 本地新建install.sh，打开https://get.k3s.io/，复制内容到install.sh\nk3s二进制文件 k3s镜像文件 下载地址\n一共三个文件\ninstall.sh k3s k3s-airgap-images-amd64.tar.gz 安装K3s k8s-master主机\n先在k8s-master主机安装K3s\n1 2 3 4 5 # 将k3s二进制文件移动到/usr/local/bin目录 sudo mv k3s /usr/local/bin # 添加执行权限 sudo chmod +x /usr/local/bin/k3s 1 2 3 4 5 # 新建目录 sudo mkdir -p /var/lib/rancher/k3s/agent/images/ # 将镜像移动到此目录（无需解压） sudo cp ./k3s-airgap-images-amd64.tar.gz /var/lib/rancher/k3s/agent/images/ 1 2 3 4 5 6 7 8 9 10 11 # 添加执行权限 sudo chmod +x install.sh # 离线安装 sudo INSTALL_K3S_SKIP_DOWNLOAD=true ./install.sh # 安装完成后，查看节点状态 sudo kubectl get node # 查看token sudo cat /var/lib/rancher/k3s/server/node-token 1 2 # token K1039d5486f90d89c63fd5b06af82594a82e20b7795d05861b402275c984ff9a359::server:0d9bdb8eb2214153d4f629e99b5baaf8 k8s-worker1、k8s-worker2主机\n接着在k8s-worker1、k8s-worker2主机安装K3s\n1 2 3 4 5 # 将k3s二进制文件移动到/usr/local/bin目录 sudo mv k3s /usr/local/bin # 添加执行权限 sudo chmod +x /usr/local/bin/k3s 1 2 3 4 5 # 新建目录 sudo mkdir -p /var/lib/rancher/k3s/agent/images/ # 将镜像移动到此目录（无需解压） sudo cp ./k3s-airgap-images-amd64.tar.gz /var/lib/rancher/k3s/agent/images/ 1 2 # 添加执行权限 sudo chmod +x install.sh 注意！！！这一步要加上k8s-master主机的ip和刚才得到的token\n1 2 3 4 5 # 离线安装 sudo INSTALL_K3S_SKIP_DOWNLOAD=true \\ K3S_URL=https://192.168.66.42:6443 \\ K3S_TOKEN=K1039d5486f90d89c63fd5b06af82594a82e20b7795d05861b402275c984ff9a359::server:0d9bdb8eb2214153d4f629e99b5baaf8 \\ ./install.sh 验证安装 k8s-master主机\n在k8s-master主机执行\n1 sudo kubectl get node -o wide 得到\n1 2 3 4 NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME k8s-worker1 Ready \u0026lt;none\u0026gt; 2d2h v1.25.4+k3s1 192.168.66.43 \u0026lt;none\u0026gt; Ubuntu 20.04.5 LTS 5.4.0-135-generic containerd://1.6.8-k3s1 k8s-worker2 Ready \u0026lt;none\u0026gt; 2d2h v1.25.4+k3s1 192.168.66.45 \u0026lt;none\u0026gt; Ubuntu 20.04.5 LTS 5.4.0-135-generic containerd://1.6.8-k3s1 k8s-master Ready control-plane,master 2d3h v1.25.4+k3s1 192.168.66.42 \u0026lt;none\u0026gt; Ubuntu 20.04.5 LTS 5.4.0-135-generic containerd://1.6.8-k3s1 证明集群安装搭建成功了\n参考资料 k3s官网 如何在Ubuntu 20.04设置主机名 Kubernetes二小时入门教程 docker一小时入门教程 ","permalink":"https://nextyu.github.io/posts/k8s/ubuntu20.04%E5%AE%89%E8%A3%85k3s%E9%9B%86%E7%BE%A4/","summary":"ubuntu20.04安装K3s集群","title":"ubuntu20.04安装K3s集群"},{"content":"一个Java程序，实际占用的内存除了堆内存，还有许多其他本地内存（native memory）。\n要想跟踪本地内存使用情况，需要在程序启动的时候增加启动参数\n-XX:NativeMemoryTracking=detail 或者 -XX:NativeMemoryTracking=summary\n注意！！！下面是以 jdk 8 HotSpot 虚拟机为例！！！\n1 java -Xms1800m -Xmx1800m -Xss512k -jar -XX:NativeMemoryTracking=summary xxx.jar # 加入启动参数 查看本地内存使用情况 jcmd PID VM.native_memory summary scale=MB\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 Native Memory Tracking: Total: reserved=3694MB, committed=2492MB - Java Heap (reserved=1800MB, committed=1800MB) (mmap: reserved=1800MB, committed=1800MB) - Class (reserved=1113MB, committed=99MB) (classes #15824) (malloc=5MB #32749) (mmap: reserved=1108MB, committed=94MB) - Thread (reserved=404MB, committed=404MB) (thread #789) (stack: reserved=400MB, committed=400MB) (malloc=3MB #3944) (arena=1MB #1576) - Code (reserved=256MB, committed=67MB) (malloc=12MB #16568) (mmap: reserved=244MB, committed=56MB) - GC (reserved=69MB, committed=69MB) (malloc=3MB #494) (mmap: reserved=66MB, committed=66MB) - Compiler (reserved=2MB, committed=2MB) (malloc=2MB #2169) - Internal (reserved=25MB, committed=25MB) (malloc=25MB #30667) - Symbol (reserved=20MB, committed=20MB) (malloc=17MB #174016) (arena=4MB #1) - Native Memory Tracking (reserved=4MB, committed=4MB) (tracking overhead=4MB) 1 2 reserved 是jvm期望使用的内存 committed 是jvm实际使用的内存 除了Java Heap使用的是堆内存，其他比如Class、Thread等都是使用的本地内存（native memory），所以一个java程序占用的内存不只有堆内存，还得加上各种Class、Thread等使用的本地内存。\n上面的例子，堆内存指定了1800m，再加上其他本地内存，整个程序实际占用了 2492m\n对比本地内存使用情况 1 2 3 4 5 jcmd PID VM.native_memory baseline // 先创建baseline // 运行一段时间之后 jcmd PID VM.native_memory summary.diff scale=MB // 对比内存分配情况 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 Native Memory Tracking: Total: reserved=3694MB +74MB, committed=2492MB +83MB - Java Heap (reserved=1800MB, committed=1800MB) (mmap: reserved=1800MB, committed=1800MB) - Class (reserved=1113MB +8MB, committed=99MB +9MB) (classes #15824 +1496) (malloc=5MB #32742 +3294) (mmap: reserved=1108MB +8MB, committed=94MB +9MB) - Thread (reserved=404MB +51MB, committed=404MB +51MB) (thread #789 +100) (stack: reserved=400MB +50MB, committed=400MB +50MB) (malloc=3MB #3944 +500) (arena=1MB #1576 +200) - Code (reserved=256MB +1MB, committed=67MB +9MB) (malloc=12MB +1MB #16572 +2031) (mmap: reserved=244MB, committed=56MB +7MB) - GC (reserved=69MB, committed=69MB) (malloc=3MB #494 +17) (mmap: reserved=66MB, committed=66MB) - Compiler (reserved=2MB, committed=2MB) (malloc=2MB #2169 +208) - Internal (reserved=25MB +12MB, committed=25MB +12MB) (malloc=25MB +12MB #30666 +3400) - Symbol (reserved=20MB +1MB, committed=20MB +1MB) (malloc=17MB +1MB #174016 +14885) (arena=4MB #1) - Native Memory Tracking (reserved=4MB +1MB, committed=4MB +1MB) (tracking overhead=4MB) 以上的例子可以看出，从创建baseline到现在，本地内存使用情况\nClass区域\n增加了9m占用 增加了1496个类 等等 Thread区域\n增加了51m占用 增加了51个线程 等等 参考资料 官方文档 JVM 堆外内存泄漏分析（一） 一个JDK的Bug与NMT 聊聊HotSpot VM的Native Memory Tracking 统计进程中的线程数 Stack Memory and Heap Space in Java JVM option -Xss - What does it do exactly? 一个 jvm 线程占用多少操作系统内存 linux下找到JVM占用资源最高的线程 Understanding Metaspace and Class Space GC Log Entries JVM Tuning Using jcmd ","permalink":"https://nextyu.github.io/posts/jvm/jvm%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98native-memory%E8%B7%9F%E8%B8%AA/","summary":"jvm本地内存（native memory）跟踪","title":"jvm本地内存（native memory）跟踪"},{"content":"Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。\n注意！！！下面是以 jdk 8 HotSpot 虚拟机为例！！！\n查看主机内存情况 1 free -h 1 2 3 total used free shared buff/cache available Mem: 3.7G 2.6G 220M 524K 921M 910M Swap: 0B 0B 0B 第一列\nMem 内存的使用信息\nSwap 交换空间的使用信息\n第一行\ntotal 系统总的可用物理内存大小\nused 已被使用的物理内存大小\nfree 还有多少物理内存可用\nshared 被共享使用的物理内存大小\nbuff/cache 被 buffer 和 cache 使用的物理内存大小\navailable 还可以被 应用程序 使用的物理内存大小\nfree 与 available 的区别 free 是真正尚未被使用的物理内存数量。\navailable 是应用程序认为可用内存数量，available = free + buffer + cache (注：只是大概的计算方法)\nLinux 为了提升读写性能，会消耗一部分内存资源缓存磁盘数据，对于内核来说，buffer 和 cache 其实都属于已经被使用的内存。但当应用程序申请内存时，如果 free 内存不够，内核就会回收 buffer 和 cache 的内存来满足应用程序的请求。\n查询java进程的PID 1 jps 1 25572 xxx.jar 得到 PID 25572\n查询gc回收信息 1 jstat -gcutil PID 1s # 每隔一秒输出gc信息 1 2 3 4 5 6 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 0.00 39.58 50.74 27.25 95.26 92.01 7261 137.361 3 0.522 137.883 0.00 39.58 51.81 27.25 95.26 92.01 7261 137.361 3 0.522 137.883 0.00 39.58 53.24 27.25 95.26 92.01 7261 137.361 3 0.522 137.883 0.00 39.58 55.74 27.25 95.26 92.01 7261 137.361 3 0.522 137.883 0.00 39.58 58.49 27.25 95.26 92.01 7261 137.361 3 0.522 137.883 S0 第 0 个 survivor（幸存区）使用的百分比\nS1 第 1 个 survivor（幸存区）使用的百分比\nE Eden 区使用内存的百分比\nO 老生代内存使用的百分比\nM MetaSpace 的内存使用百分比\nCCS 压缩类空间利用率百分比\nYGC 程序启动以来 Young GC 发生的次数\nYGCT 程序启动以来 Young GC 共消耗的时间(s)\nFGC 程序启动以来 Full GC 发生的次数\nFGCT 程序启动以来 Full GC 共消耗的时间(s)\nGCT 程序启动以来 GC 的总用时(s)\ndump出jvm堆内存 1 jmap -dump:live,format=b,file=/tmp/jvm_xxx.bin PID 把jvm_xxx.bin下载到本地计算机\n下载 Eclipse Memory Analyzer（mat）\n新版本的mat需要jdk11，建议下载老版本\n下载地址\n使用mat打开jvm_xxx.bin文件，mat会自动分析堆文件，分析完成之后点击Leak Suspects，一般就能看出哪些对象占用了大量内存\n如果dump出的堆文件特别大，mat打开报内存不足，可以修改mat配置文件，适当加大堆内存容量\nMemoryAnalyzer.ini\n1 2 -Xms4096m -Xmx4096m 参考资料 QQA: jstat gcutil 的输出是什么意思 jstat linux free 命令下free/available区别 free ","permalink":"https://nextyu.github.io/posts/jvm/jvm%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E6%8E%92%E6%9F%A5/","summary":"JVM堆内存溢出排查","title":"JVM堆内存溢出排查"},{"content":"内存溢出（memory overflow） 内存溢出表示程序向操作系统申请内存，但是没有足够的内存可以使用了，就会导致内存不足。\n内存泄露（memory leak） 内存泄露表示程序使用过的内存，没有释放掉，操作系统不能再分配这些内存。内存泄露会导致可使用的内存越来越少，最终会导致内存不足。\n参考资料 The difference between memory overflow and memory leak and how to avoid memory overflow ","permalink":"https://nextyu.github.io/posts/jvm/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"内存溢出和内存泄露的区别","title":"内存溢出和内存泄露的区别"},{"content":"注意！！！ kms 只能激活Business Edition（商业版），不能激活 Consumer Edition（消费者版）\nBusiness Edition（商业版）和 Consumer Edition（消费者版）区别如下：\nWindows Business Edition（商业版）\n目标用户：企业、公司、IT部门、专业用户\n功能特点：\n增强的安全性：包括BitLocker、Windows Information Protection（WIP）等高级数据保护功能。 远程桌面：允许用户远程连接和控制其他设备。 企业管理工具：如Group Policy、Windows Update for Business、Microsoft Endpoint Manager（包括Intune）等。 虚拟化：Hyper-V虚拟化技术。 Windows Sandbox：用于测试不信任的软件。 企业商店：Microsoft Store for Business，允许管理员分发应用程序。 典型版本：\nWindows 11 Pro：适合小型企业和高级用户。 Windows 11 Enterprise：面向大中型企业，包含Pro版本所有功能及更多企业级管理功能。 Windows 11 Education：类似于Enterprise版，但针对教育机构。 Windows Consumer Edition（消费者版）\n目标用户：普通消费者、家庭用户、学生\n功能特点：\n用户友好：简化的界面和易于使用的功能。 娱乐功能：如Windows Media Player、游戏模式、Xbox集成等。 家庭共享：家庭组和家庭共享功能。 微软账户同步：跨设备同步设置和应用程序。 简化的更新：通过Windows Update进行简化更新，无需复杂的IT管理。 典型版本：\nWindows 11 Home：面向家庭和普通用户，提供基本的家庭计算功能。 所以重装系统，下载Business Edition，里面包含了各种版本，安装的时候，直接选择安装专业版（Pro），功能全。\n下载 win11 business edition MSDN,我告诉你\n下载vlmcsd 下载地址\n需要两台电脑，不能自己激活自己。\n运行vlmcsd服务端（windows版） 此为kms服务端，其他电脑可以连上这台电脑激活，假设此电脑的的ip地址为：192.168.31.100\n管理员模式运行 PowerShell\n1 2 3 4 5 cd D:\\binaries\\binaries\\Windows\\intel # 进入vlmcsd解压之后的目录 ./vlmcsd-Windows-x64.exe # 默认运行在1688端口 ./vlmcs-Windows-x64.exe 127.0.0.1:1688 # 测试是否可用 激活win11专业版 此为需要激活的电脑，假设此电脑的的ip地址为：192.168.31.101，和kms服务端在同一个局域网\n管理员模式运行 PowerShell\n1 2 3 4 5 6 7 8 9 slmgr.vbs /upk # 清除密钥 slmgr.vbs /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX # 添加密钥 win11专业版 slmgr.vbs /skms 192.168.31.100:1688 # 设置kms服务器 slmgr.vbs /ato # 激活 slmgr.vbs /xpr # 查看激活时效 备注 kms激活有效期只有180天，过期之后需要再次激活，再次重复上面的激活步骤即可。\n参考资料 window激活密钥 KMS 服务器 vlmcsd 的安装和激活 MSDN,我告诉你 ","permalink":"https://nextyu.github.io/posts/windows/%E4%BD%BF%E7%94%A8vlmcsd%E6%BF%80%E6%B4%BBwindow-10window-11/","summary":"使用vlmcsd激活window 10、window 11","title":"使用vlmcsd激活window 10 window 11"},{"content":"主要用于记录一些学习笔记。\n","permalink":"https://nextyu.github.io/about/","summary":"主要用于记录一些学习笔记。","title":"关于"}]